# R数据结构-续

### 6.1列表类型

R中列表(list)类型来保存不同类型的数据。**实际上，数据框也是列表的一种， 但是数据框要求各列等长， 而列表不要求。**

定义列表用函数`list()`。

```R
rec <- list(name="李明", age=30,
  scores=c(85, 76, 90))
rec
## $name
## [1] "李明"
## 
## $age
## [1] 30
## 
## $scores
## [1] 85 76 90

typeof(rec)
## [1] "list"
is.list(rec)
## [1] TRUE

#generate a list with n length and NULL element
vector("list", 4)
##[[1]]
##NULL
##[[2]]
##NULL
##[[3]]
##NULL
##[[4]]
##NULL
```

单个列表元素必须用两重方括号或`$`格式访问，如果使用单重方括号对列表取子集， 结果还是列表而不是列表元素。

```R
rec[[3]]
## [1] 85 76 90
rec$scores
## [1] 85 76 90
rec[3]
## $scores
## [1] 85 76 90
```

使用`names()`查看与修改列表的元素名。直接给列表不存在的元素名定义元素值就添加了新元素。

```R
names(rec)
## [1] "name" "age" "scores"
names(rec)[names(rec)=="scores"]<-"分数"
names(rec)
## [1] "name" "age" "分数"
rec[['身高']]<-178
rec$身高
## [1] 178
```

把某个列表元素赋值为`NULL`就删掉这个元素。在`list()`函数中允许定义元素为`NULL`，这样的元素是存在的。但在`list()`函数中允许定义元素为`NULL`，这样的元素是存在的

```R
rec[["age"]] <- NULL
print(rec)
## $name
## [1] "李明"
## 
## $三科分数
## [1] 85  0 90
## 
## $身高
## [1] 178
li <- list(a=120, b="F", c=NULL); li
## $a
## [1] 120
## 
## $b
## [1] "F"
## 
## $c
## NULL
```

要把已经存在的元素修改为NULL值而不是删除此元素， 或者给列表增加一个取值为NULL的元素， 这时需要用单重的方括号取子集， 这样的子集会保持其列表类型， 给这样的子列表赋值为`list(NULL)`。

```R
li["b"] <- list(NULL)
li["d"] <- list(NULL)
li
## $a
## [1] 120
## 
## $b
## NULL
## 
## $c
## NULL
## 
## $d
## NULL
```

#### 类型转换

用`as.list()`把一个其它类型的对象转换成列表； 用`unlist()`函数把列表转换成基本向量。

```R
li1 <- as.list(1:3)
li1
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
li2 <- list(x=1, y=c(2,3))
unlist(li2)
##  x y1 y2 
##  1  2  3
```

#### 列表连接

两个列表可以用`c`连接成一个列表。

```R
li1 <- list(1:2)
li2 <- list(11:12)
li <- c(li1, li2)
li
## [[1]]
## [1] 1 2
## 
## [[2]]
## [1] 11 12
```

```R
li <- list()
li <- c(li, 1:3)
li <- c(li, 11:13)
li
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 11
## 
## [[5]]
## [1] 12
## 
## [[6]]
## [1] 13

li <- list()
li <- c(li, list(1:3))
li <- c(li, list(11:13))
li
## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] 11 12 13
```

#### 返回列表

`strsplit()`输入一个字符向量，对其中每一个字符串进行分割，生成一个列表。

```R
x <- c("10, 8, 7", "5, 2, 2", "3, 7, 8", "8, 8, 9")
res <- strsplit(x, ","); res
## [[1]]
## [1] "10" " 8" " 7"
## 
## [[2]]
## [1] "5"  " 2" " 2"
## 
## [[3]]
## [1] "3"  " 7" " 8"
## 
## [[4]]
## [1] "8"  " 8" " 9"

# list trans to matrix
t(sapply(res, as.numeric))
##      [,1] [,2] [,3]
## [1,]   10    8    7
## [2,]    5    2    2
## [3,]    3    7    8
## [4,]    8    8    9
```

### 6.2 R矩阵与数组

矩阵用matrix函数定义，实际存储成一个向量，根据保存的行数和列数对应到矩阵的元素， 存储次序为按列存储。

```R
A <- matrix(11:16, nrow=3, ncol=2); print(A)
##      [,1] [,2]
## [1,]   11   14
## [2,]   12   15
## [3,]   13   16

#fill by row
B <- matrix(c(1,-1, 1,1), nrow=2, ncol=2, byrow=TRUE); print(B)
##      [,1] [,2]
## [1,]    1   -1
## [2,]    1    1
```

可以使用`nrow()`与`ncol()`访问矩阵的行数与列数，使用`dim()`获取矩阵的行列。`t()`获取矩阵转置。

```R
nrow(A)
## [1] 3
ncol(A)
## [1] 2
dim(A)
## [1] 3 2
t(A)
##     [,1] [,2] [,3]
##[1,]   11   12   13
##[2,]   14   15   16
```

#### 矩阵子集

用`A[1,]`取出A的第一行，变成一个普通向量。 用`A[,1]`取出A的第一列，变成一个普通向量。 用`A[c(1,3),1:2]`取出指定行、列对应的子矩阵。

```R
A[1,]
## [1] 11 14
A[,1]
## [1] 11 12 13
A[c(1,3),1:2]
##      [,1] [,2]
## [1,]   11   14
## [2,]   13   16
```

用`colnames()`函数可以给矩阵每列命名， 也可以访问矩阵列名， 用`rownames()`函数可以给矩阵每行命名， 也可以访问矩阵行名。

```R
colnames(A) <- c('X', 'Y')
rownames(A) <- c('a', 'b', 'c')
A
##    X  Y
## a 11 14
## b 12 15
## c 13 16
```

矩阵可以有一个dimnames属性， 此属性是两个元素的列表， 两个元素分别为矩阵的行名字符型向量与列名字符型向量。 如果仅有其中之一，缺失的一个取为`NULL`。

**注意在对矩阵取子集时， 如果取出的子集仅有一行或仅有一列， 结果就不再是矩阵而是变成了R向量， R向量既不是行向量也不是列向量。** 如果想避免这样的规则起作用， 需要在方括号下标中加选项`drop=FALSE`

```R
A[,1,drop=FALSE]
##    X
## a 11
## b 12
## c 13
```

**矩阵本质上是一个向量添加了`dim`属性， 实际保存还是保存成一个向量**， 其中元素的保存次序是按列填入， 所以， 也可以向对一个向量取子集那样， 仅用一个正整数向量的矩阵取子集。

```R
A
##    X  Y
## a 11 14
## b 12 15
## c 13 16
A[c(1,3,5)]
## [1] 11 13 15
```

为了挑选矩阵的任意元素组成的子集而不是子矩阵， 可以用一个两列的矩阵作为下标， 矩阵的每行的两个元素分别指定一个元素的行号和列号。

```R
ind <- matrix(c(1,1, 2,2, 3,2), ncol=2, byrow=TRUE)
ind
##      [,1] [,2]
## [1,]    1    1
## [2,]    2    2
## [3,]    3    2
A[ind]
## [1] 11 15 16
```

用`c(A)`或`A[]`返回矩阵`A`的所有元素。 如果要修改矩阵`A`的所有元素， 可以对`A[]`赋值。

对矩阵`A`，`diag(A)`访问`A`的主对角线元素组成的向量。 另外，若`x`为正整数值标量，`diag(x)`返回`x`阶单位阵； 若`x`为长度大于1的向量， `diag(x)`返回以`x`的元素为主对角线元素的对角矩阵。

```R
c(A)
## [1] 11 12 13 14 15 16
x<-4
diag(x)
##     [,1] [,2] [,3] [,4]
##[1,]    1    0    0    0
##[2,]    0    1    0    0
##[3,]    0    0    1    0
##[4,]    0    0    0    1
diag(c(1,2,3,4))
##     [,1] [,2] [,3] [,4]
##[1,]    1    0    0    0
##[2,]    0    2    0    0
##[3,]    0    0    3    0
##[4,]    0    0    0    4
```

若`x`是向量，`cbind(x)`把`x`变成列向量， 即列数为1的矩阵， `rbind(x)`把`x`变成行向量。若`x1`, `x2`, `x3`是等长的向量， `cbind(x1, x2, x3)`把它们看成列向量并在一起组成一个矩阵。

```R
cbind(c(1,2), c(3,4), c(5,6))
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
cbind(A, c(1,-1,10))
##    X  Y   
## a 11 14  1
## b 12 15 -1
## c 13 16 10
cbind(1, c(1,-1,10))
##      [,1] [,2]
## [1,]    1    1
## [2,]    1   -1
## [3,]    1   10
```

#### 矩阵运算

矩阵可以与标量作四则运算，结果为每个元素进行相应运算。

```R
C1 <- A + 2; C1
##    X  Y
## a 13 16
## b 14 17
## c 15 18
C2 <- A / 2; C2
##     X   Y
## a 5.5 7.0
## b 6.0 7.5
## c 6.5 8.0
```

两个同形状的矩阵进行加、减，乘除运算， 即对应元素相加、相减、相乘、相除。

```R
C1 * C2
##      X     Y
## a 71.5 112.0
## b 84.0 127.5
## c 97.5 144.0
```

用`%*%`表示矩阵乘法而不是用`*`表示， 注意矩阵乘法要求左边的矩阵的列数等于右边的矩阵的行数。 

```R
A
##    X  Y
## a 11 14
## b 12 15
## c 13 16
B
##      [,1] [,2]
## [1,]    1   -1
## [2,]    1    1
C3 <- A %*% B; C3
##   [,1] [,2]
## a   25    3
## b   27    3
## c   29    3
```

矩阵与向量进行乘法运算时， 向量按需要解释成列向量或行向量。 当向量左乘矩阵时，看成行向量； 当向量右乘矩阵时，看成列向量。

```R
c(1,1) %*% B
##      [,1] [,2]
## [1,]    2    0
B %*% c(1,1)
##      [,1]
## [1,]    2
```

**注意矩阵乘法总是给出矩阵结果， 即使此矩阵已经退化为行向量、列向量甚至于退化为标量也是一样。 如果需要，可以用`c()`函数把一个矩阵转换成按列拉直的向量。**

#### 内积

设`x`, `y`是两个向量， 计算向量内积， 可以用`sum(x*y)`表示。设A,B 是两个矩阵， A^TB是广义的内积， 也称为叉积(crossprod)， 结果是一个矩阵， 元素为的每列与的每列计算内积的结果。 A^TB在R中可以表示为`crossprod(A, B)`, A^TA可以表示为`crossprod(A)`。 要注意的是，`crossprod()`的结果总是矩阵， 所以计算两个向量的内积用`sum(x,y)`而不用`crossprod(x,y)`。

#### 外积

R向量支持外积运算， 记为`%o%`, 结果为矩阵。 `x %o% y`的第行第列元素等于x[i]乘以y[j]。

```R
c(1,2,3) %o% c(1, -1)
##      [,1] [,2]
## [1,]    1   -1
## [2,]    2   -2
## [3,]    3   -3
```

这种运算还可以推广到`x`的每一元素与`y`的每一元素进行其它的某种运算， 而不限于乘积运算，可以用`outer(x,y,f)`完成， 其中`f`是某种运算，或者接受两个自变量的函数。

#### 逆矩阵与线性方程组求解

用`solve(A)`求`A`的逆矩阵。用`solve(A,b)`可求解线性方程组`Ax=b`中的x。

```R
solve(B)
##      [,1] [,2]
## [1,]  0.5  0.5
## [2,] -0.5  0.5
solve（B,c(1,2))
## [1] 1.5 0.5
```

#### apply()函数

`apply(A, 1, FUN)`把矩阵`A`的每一行分别输入到函数FUN中， 得到与每一行对应的结果。而`apply(A, 2, FUN)`得到对应每一列的结果。

```R
D <- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2); D
##      [,1] [,2]
## [1,]    6    5
## [2,]    2    4
## [3,]    3    1
apply(D, 1, mean)
## [1] 5.5 3.0 2.0
apply(D, 2, sum)
## [1] 11 10
```

如果函数FUN返回多个结果， 则`apply(A, 2, FUN)`结果为矩阵， 矩阵的每一列是输入矩阵相应列输入到FUN的结果， 结果列数等于`A`的列数。而为了对每行计算FUN的结果， 结果存入一个与输入的矩阵行数相同的矩阵， 应该用`t(apply(A, 1, FUN))`的形式

```R
apply(D, 2, range)
##      [,1] [,2]
## [1,]    2    1
## [2,]    6    5
t(apply(D, 1, range))
##      [,1] [,2]
## [1,]    5    6
## [2,]    2    4
## [3,]    1    3
```

#### 多维数组

矩阵是多维数组(array)的特例。 给一个向量添加一个`dim`属性就可以把它变成多维数组。

多维数组的一般定义语法为：

```R
数组名 <- array(数组元素, 
  dim=c(第一下标个数, 第二下标个数, ..., 第s下标个数))
```

**其中数组元素的填入次序是第一下标变化最快， 第二下标次之， 最后一个下标是变化最慢的。 这种次序称为FORTRAN次序。**

```R
ara <- array(1:24, dim=c(2,3,4)); ara
## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]    7    9   11
## [2,]    8   10   12
## 
## , , 3
## 
##      [,1] [,2] [,3]
## [1,]   13   15   17
## [2,]   14   16   18
## 
## , , 4
## 
##      [,1] [,2] [,3]
## [1,]   19   21   23
## [2,]   20   22   24
ara[,,2]
##      [,1] [,2] [,3]
## [1,]    7    9   11
## [2,]    8   10   12
```

多维数组可以利用下标进行一般的子集操作， 比如`ara[,2, 2:3]` 的值， 结果是一个矩阵:

```R
ara[,2,2:3]
##      [,1] [,2]
## [1,]    9   15
## [2,]   10   16
```

**多维数组在取子集时如果某一维下标是标量， 则结果维数会减少， 可以在方括号内用`drop=FALSE`选项避免这样的规则发生作用。**

**类似于矩阵， 多维数组可以用一个矩阵作为下标， 如果是三维数组，矩阵就需要有3列， 四维数组需要用4列矩阵。 下标矩阵的每行对应于一个数组元素。**

#### 列表类型的数组

矩阵一般用于数值计算， 所以其元素一般是数值。 但是， 在更复杂的编程场景中， 可能需要在矩阵（或数组）元素中保存复杂结构， 比如， 每个元素是一个长度可变的向量。 这时， 可以将矩阵元素设为列表类型， 但访问其元素需要使用部分列表访问语法格式。

如果矩阵元素是长度为1的列表， 则只要给`L[1,1]`赋值为一个长度为1的列表， 访问元素内容时用`L[1,1][[1]]`的语法。 如果需要在矩阵元素中保存长度大于1的列表， 就需要将元素的实际内容保存成一个长度为大于1的列表。

### 6.3数据框

统计分析中最常见的原始数据形式是类似于数据库表或Excel数据表的形式。 这样形式的数据在R中叫做数据框(data.frame)。

在R中数据框是一个特殊的列表， 其每个列表元素都是一个长度相同的向量。 事实上，数据框还允许一个元素是一个矩阵， 但这样会使得某些读入数据框的函数发生错误。

函数`data.frame()`可以生成数据框。

```R
d <- data.frame(
    name=c("李明", "张聪", "王建"), 
    age=c(30, 35, 28), 
    height=c(180, 162, 175),
    stringsAsFactors=FALSE)
print(d)
##   name age height
## 1 李明  30    180
## 2 张聪  35    162
## 3 王建  28    175
```

**`data.frame()`函数会将字符型列转换成因子， 加选项`stringsAsFactors=FALSE`可以避免这样的转换。**

如果数据框的某一列为常数， 可以在`data.frame()`调用中仅给该列赋一个值， 生成的结果会自动重复这个值使得该列与其他列等长。

使用`names(d)`或`colnames(d)`可以访问或修改列名。

```R
nrow(d)
## [1] 3
ncol(d)
## [1] 3
names(d)
## [1] "name"   "age"    "height"
colnames(d)
## [1] "name"   "age"    "height"
```

用`as.data.frame(x)`可以把`x`转换成数据框。 如果`x`是一个向量， 转换结果是以`x`为唯一一列的数据框。 如果`x`是一个列表并且列表元素都是长度相同的向量， 转换结果中每个列表变成数据框的一列。 如果`x`是一个矩阵，转换结果把矩阵的每列变成数据框的一列。

#### 数据框的访问

数据框可以用矩阵格式访问。

```R
d[2,3]
## [1] 162
d[[2]]
## [1] 30 35 28
d[,2]
## [1] 30 35 28
```

按列名访问列。

```R
d[["age"]]
## [1] 30 35 28
d[,"age"]
## [1] 30 35 28
d$age
## [1] 30 35 28
```

**因为数据框的一行不一定是相同数据类型， 所以数据框的一行作为子集， 结果还是数据框，而不是向量。**

```R
x <- d[2,]; x
##   name age height
## 2 张聪  35    162
is.data.frame(x)
## [1] TRUE
```

可以同时取行子集和列子集。

```R
d[1:2, "age"]
## [1] 30 35
d[1:2, c("age", "height")]
##   age height
## 1  30    180
## 2  35    162
d[d[,"age"]>=30,]
##   name age height
## 1 李明  30    180
## 2 张聪  35    162
```

用如`d[,"age"]`, `d[,2]`这样的方法取出的数据框的单个列**是向量而不再是数据框**。 但是，如果取出**两列或者两列以上**， 结果则是数据框。 如果取列子集时不能预先知道取出的列个数， 则子集结果有可能是向量也有可能是数据框， 容易造成后续程序错误。 对一般的数据框， 可以在取子集的方括号内加上`drop=FALSE`选项， 确保取列子集的结果总是数据框。 

#### 数据框的行名

```R
rownames(d) <- d$name
d$name <- NULL
d
##      age height
## 李明  30    180
## 张聪  35    162
## 王建  28    175
```

#### 数据框与矩阵的区别

数据框不能作为矩阵参加矩阵运算。 需要时，可以用`as.matrix()`函数转换数据框或数据框的子集为矩阵。

```R
d2 <- as.matrix(d[,c("age", "height")])
d3 <- crossprod(d2); d3
##          age height
## age     2909  15970
## height 15970  89269
```

#### tibble类型

tibble类型是一种改进的数据框。 readr包的`read_csv()`函数是`read.csv()`函数的一个改进版本， 它将csv文件读入为tibble类型。

```R
library(tibble)
library(readr)
d.class <- read_csv("test.csv")
class(d.class)
## [1] "spec_tbl_df" "tbl_df" "tbl" "data.frame"
```

用`as_tibble()`可以将一个数据框转换为tibble, dplyr包提供了`filter()`、`select()`、`arrange()`、`mutate()` 等函数用来对tibble选取行子集、列子集，排序、修改或定义新变量。

可以用`tibble()`函数生成小的tibble。在调用`tibble()`函数时， 定义在后面的列可以调用前面的列的值。

```R
d.bp <- tibble(
  `序号`=c(1,5,6,9,10,15),
  `收缩压`=c(145, 110, "未测", 150, "拒绝", 115)) 
```

### 6.4工作空间与变量赋值

用`ls()`命令可以查看工作空间中的内容，用`rm()`函数删除工作空间中的变量。

```R
ls()
## [1] "a" "A" "age" "age1" "ages" "ara"
rm(a)
ls()
## [1] "A" "age" "age1" "ages" "ara"
```

### 6.5多线程

