## 程序结构

### 表达式

R是一个表达式语言, 其任何一个语句都可以看成是一个表达式。若干个表达式可以放在一起组成一个复合表达式, 作为一个表达式使用，复合表达式的值为最后一个表达式的值， 组合用大括号表示。

### 分支结构

```R
if (条件) 表达式1 else 表达式2
```

函数`ifelse()`可以根据一个逻辑向量中的多个条件， 分别选择不同结果。

```R
x <- c(-2, 0, 1)
y <- ifelse(x >=0, 1, 0); print(y)
## [1] 0 1 1
```

函数`ifelse(test, yes, no)`中的`test`是逻辑向量， `yes`和`no`是向量， `test`、`yes`和`no`的配合符合向量化原则， 如果有长度为1的或者长度较短但其倍数等于最长一个的长度的， 短的一个自动从头循环使用。

```R
ifelse((1:6) >= 3, 1:2, c(-1,-2))
## [1] -1 -2  1  2  1  2
```

#### switch 函数

函数`switch()`可以建立多分枝结构, 可以根据一个整数表达式或者一个字符串表达式的值选择返还相对应的值。

```R
gr_v <- c("A+", "A", "A-", "B+", "B", "B-", 
  "C+", "C", "C-", "D+", "F", "EX")
for(gr in gr_v){
  switch(gr,
    "A+" = 99,
    "A" = 96,
    "A-" = 92,
    "B+" = 87,
    "B" = 82,
    "B-" = 78,
    "C+" = 75,
    "C" = 71,
    "C-" = 68,
    "D+" = 65,
    "F" = 50,
    NA)
}
```

`switch()`中允许对多个值采取同一行动或者返回同一结果。

```R
for(ch in c("a", "i", "c")){
  cat(ch, ":", switch(ch,
    "a"=, "e"=, "i"=, "o"=, "u" = "Vower",
    "Consonant"), "\n")
}
## a : Vower 
## i : Vower 
## c : Consonant
```

### 循环结构

为了对向量每个元素、矩阵每行、矩阵每列循环处理，语法为

> for(循环变量 in 序列) 语句

其中的语句一般是复合语句。

```R
set.seed(101); x <- rnorm(5)
y <- numeric(length(x))
for(i in 1:5){
  if(x[i]>=0) y[i] <- 1 else y[i] <- 0
}
print(y)
## [1] 0 1 0 1 1
```

如果需要对某个向量`x`按照下标循环， 获得所有下标序列的标准写法是`seq_along(x)`

用

> while(循环继续条件) 语句

进行当型循环。 其中的语句一般是复合语句。 仅当条件成立时才继续循环， 而且如果第一次条件就已经不成立就一次也不执行循环内的语句。

用

> repeat 语句

进行无条件循环（一般在循环体内用if与break退出）。

```R
repeat{
  ...
  if(循环退出条件) break
}
```

**if语句和while语句中用到条件。 条件必须是标量值， 而且必须为TRUE或FALSE， 不能为NA或零长度。**

### 管道控制

数据处理中经常会对同一个变量（特别是数据框）进行多个步骤的操作， 比如，先筛选部分有用的变量，再定义若干新变量，再排序。变量`x`先用函数`f(x)`进行变换，再用函数`g(x)`进行变换， 一般应该写成`g(f(x))`，用`|>`运算符，可以表示成 `x |> f() |> g()`。

**处理用的函数也可以带有其它自变量，在管道控制中不要写第一个自变量。**

```R
2 |> sqrt() |> exp()
## [1] 4.11325
```

在`|>`表示的管道中， 上一步的输出通过管道作为下一步的第一个自变量。 如果需要当作下一步的其它自变量， 可以用`自变量名 = _`的特殊格式， 这里`_`代表管道中上一步的结果。

```R
6 |> round(pi,  digits = _)
## [1] 3.141593
```

## 函数

函数调用时，如果形式参数`x`的实参是一个向量， 则结果也是向量，结果元素为实参向量中对应元素的变换值。

```R
f<-function(x,y,){
    ...
}
```

为了返回多个值， 将结果打包为一个列表返回即可； R的统计建模函数的返回值大多数都是列表。

### 函数递归调用

R中在递归调用时， 最好用 `Recall` 代表调用自身， 这样保证函数即使被改名（在R中函数是一个对象， 改名后仍然有效）递归调用仍指向原来定义。

求斐波那契数列：

```R
fib1 <- function(n){
  if(n == 0) return(0)
  else if(n == 1) return(1)
  else if(n >=2 ) {
    return(Recall(n-1) + Recall(n-2))
  }
}
for(i in 0:10) cat("i =", i, " x[i] =", fib1(i), "\n")
```

### 向量化

自定义的函数，如果其中的计算都是向量化的， 那么函数自动地可以接受向量作为输入，结果输出向量。

函数`Vectorize`可以将针对单个元素操作的函数，拓展成对于向量的操作。

```R
g <- function(x){
  if(abs(x) <= 1) {
    y <- x^2
  } else {
    y <- 1
  }
  
  y
}
gv <- Vectorize(g)
```